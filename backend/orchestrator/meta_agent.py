"""Meta-agent for task decomposition using Claude Sonnet 4.5."""

import logging
from typing import Optional

from pydantic import BaseModel

from backend.llm.bedrock_client import BedrockClient, BedrockInvocationError, JSONParseError
from backend.llm.prompt_templates import get_task_decomposition_prompt
from backend.orchestrator.dependency_graph import DependencyGraph, TaskNode
from backend.queue.redis_queue import Task

logger = logging.getLogger(__name__)


class ProjectPlan(BaseModel):
    """Project plan generated by meta-agent."""
    project_name: str
    description: str
    estimated_total_hours: float
    tasks: list[Task]


class MetaAgent:
    """Meta-agent that decomposes requirements into parallelizable tasks."""

    def __init__(self, bedrock_client: BedrockClient):
        """
        Initialize meta-agent.

        Args:
            bedrock_client: Bedrock client for Claude API calls
        """
        self.bedrock = bedrock_client

    def analyze_requirements(
        self,
        requirements: str,
        project_id: str,
        project_context: Optional[str] = None
    ) -> ProjectPlan:
        """
        Analyze requirements and generate parallelizable task breakdown.

        Uses Claude Sonnet 4.5 to:
        1. Understand project requirements
        2. Identify major components
        3. Break into granular, parallelizable tasks
        4. Assign appropriate agent types
        5. Identify dependencies

        Args:
            requirements: User requirements (text description)
            project_id: Unique project identifier
            project_context: Optional context about existing project

        Returns:
            ProjectPlan with tasks and dependencies

        Raises:
            MetaAgentError: If decomposition fails
        """
        logger.info(f"Analyzing requirements for project {project_id}")

        # Generate prompt
        prompt = get_task_decomposition_prompt(requirements, project_context)

        # Expected JSON schema
        schema = {
            "project_name": "string",
            "description": "string",
            "estimated_total_hours": "number",
            "tasks": [
                {
                    "id": "string",
                    "title": "string",
                    "description": "string",
                    "agent_type": "string",
                    "estimated_hours": "number",
                    "files_to_create": ["string"],
                    "files_to_modify": ["string"],
                    "dependencies": ["string"]
                }
            ]
        }

        try:
            # Invoke Claude with JSON schema
            response_data = self.bedrock.invoke_model_with_json_schema(
                prompt=prompt,
                json_schema=schema,
                system_prompt="You are an expert software architect and project planner."
            )

            # Parse response into ProjectPlan
            tasks = []
            for task_data in response_data.get("tasks", []):
                task = Task(
                    id=task_data["id"],
                    title=task_data["title"],
                    description=task_data["description"],
                    agent_type=task_data["agent_type"],
                    files_to_create=task_data.get("files_to_create", []),
                    files_to_modify=task_data.get("files_to_modify", []),
                    dependencies=task_data.get("dependencies", []),
                    estimated_hours=task_data.get("estimated_hours", 2.0),
                    project_id=project_id
                )
                tasks.append(task)

            project_plan = ProjectPlan(
                project_name=response_data["project_name"],
                description=response_data["description"],
                estimated_total_hours=response_data.get("estimated_total_hours", sum(t.estimated_hours for t in tasks)),
                tasks=tasks
            )

            logger.info(
                f"Generated project plan: {project_plan.project_name} "
                f"({len(tasks)} tasks, {project_plan.estimated_total_hours}h estimated)"
            )

            return project_plan

        except (BedrockInvocationError, JSONParseError) as e:
            logger.error(f"Failed to analyze requirements: {e}")
            raise MetaAgentError(f"Task decomposition failed: {e}") from e

    def create_dependency_graph(self, project_plan: ProjectPlan) -> DependencyGraph:
        """
        Build dependency graph from project plan.

        Args:
            project_plan: Project plan with tasks

        Returns:
            Dependency graph

        Raises:
            MetaAgentError: If graph validation fails (e.g., circular dependencies)
        """
        logger.info(f"Building dependency graph for {len(project_plan.tasks)} tasks")

        graph = DependencyGraph()

        # Add all tasks as nodes
        for task in project_plan.tasks:
            node = TaskNode(
                task_id=task.id,
                title=task.title,
                agent_type=task.agent_type,
                dependencies=task.dependencies.copy(),
                estimated_hours=task.estimated_hours
            )
            graph.add_node(node)

        # Validate graph is acyclic
        is_valid, cycle = graph.validate_acyclic()
        if not is_valid:
            error_msg = f"Circular dependency detected: {' -> '.join(cycle)}"
            logger.error(error_msg)
            raise MetaAgentError(error_msg)

        # Log graph statistics
        sequential_hours = graph.get_total_estimated_hours()
        parallel_hours = graph.get_parallel_estimated_hours()
        speedup = sequential_hours / parallel_hours if parallel_hours > 0 else 1.0

        critical_path, critical_hours = graph.get_critical_path()

        logger.info(
            f"Dependency graph created: "
            f"sequential={sequential_hours:.1f}h, "
            f"parallel={parallel_hours:.1f}h, "
            f"speedup={speedup:.1f}x, "
            f"critical_path_length={len(critical_path)}"
        )

        return graph

    def get_initial_tasks(self, graph: DependencyGraph) -> list[TaskNode]:
        """
        Get tasks that can be started immediately (no dependencies).

        Args:
            graph: Dependency graph

        Returns:
            List of tasks ready to execute
        """
        ready_tasks = graph.get_ready_tasks()
        logger.info(f"Found {len(ready_tasks)} initial tasks ready to execute")
        return ready_tasks

    def get_execution_plan(self, graph: DependencyGraph) -> dict:
        """
        Generate execution plan with parallelization strategy.

        Args:
            graph: Dependency graph

        Returns:
            Execution plan with levels and statistics
        """
        levels = graph.get_execution_order()
        critical_path, critical_hours = graph.get_critical_path()

        plan = {
            "total_levels": len(levels),
            "levels": [
                {
                    "level_number": i + 1,
                    "parallel_tasks": len(level),
                    "task_ids": level,
                    "estimated_hours": max(
                        graph.nodes[task_id].estimated_hours
                        for task_id in level
                    )
                }
                for i, level in enumerate(levels)
            ],
            "critical_path": {
                "task_ids": critical_path,
                "total_hours": critical_hours
            },
            "statistics": {
                "total_tasks": len(graph.nodes),
                "sequential_hours": graph.get_total_estimated_hours(),
                "parallel_hours": graph.get_parallel_estimated_hours(),
                "speedup_factor": graph.get_total_estimated_hours() / graph.get_parallel_estimated_hours()
            }
        }

        return plan


class MetaAgentError(Exception):
    """Raised when meta-agent operations fail."""
    pass
